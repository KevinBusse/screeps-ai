module.exports = {

  spawn: function (desired) {
    var spawnPoint = Game.spawns[Object.keys(Game.spawns)[0]];
    var active = _.filter(Game.creeps, (creep) => creep.memory.role === 'carrier');
    var energyShare = Math.floor(0.4 * spawnPoint.room.energyCapacityAvailable);


    if (active.length < desired) {
      if (spawnPoint.room.energyAvailable < energyShare) {
        return false;
      }

      //Calculate remaining energy for Carry and Move  genes
      let carryAndMove = Math.floor((spawnPoint.room.energyAvailable  ) / 100);
      let dna = []; // Move 50, Carry 50


      while (carryAndMove--) {
        dna.push(CARRY);
        dna.push(MOVE);
      }
      let newCreep = spawnPoint.createCreep(dna, '', {role: 'carrier', target: false});
      console.log('SPAWN Collector ' + JSON.stringify(dna) + ' ' + newCreep);
      return true;
    }
    return false;

  },

  /** @param {Creep} creep **/
  run: function (creep) {



    if (creep.carryCapacity > creep.carry.energy) {

      if (creep.memory.target === false) {


        //Select dropped energy > 1000
        creep.memory.target = Game.rooms[creep.room.name].find(FIND_DROPPED_ENERGY, {
          filter: (drop) => {

            return drop.energy > 200;
          }
        });
        if (creep.memory.target[0]) {
          creep.memory.target = creep.memory.target[0].id;
        }

      }


      if (creep.memory.target) {
        let target = Game.getObjectById(creep.memory.target);
        let pickupAttempt = creep.pickup(target);

        switch (pickupAttempt) {
          case ERR_NOT_IN_RANGE:
            creep.moveTo(target);
            break;
          case OK:
          case ERR_INVALID_TARGET:
          case ERR_BUSY:
            creep.memory.target = false;
            break;
          case ERR_FULL:
            creep.memory.unload = true;
            break;


          default:
            console.log('PICKUP Failed ' + pickupAttempt);
        }
      }


    }


    if (creep.carryCapacity === creep.carry.energy || creep.memory.unload === true) {
      creep.memory.unload = true;

      var targets = creep.room.find(FIND_STRUCTURES, {
            filter: (structure) => {
              return (structure.structureType === STRUCTURE_EXTENSION ||
                  structure.structureType === STRUCTURE_SPAWN ||
                  structure.structureType === STRUCTURE_TOWER) && structure.energy < structure.energyCapacity;
            }
          })
          ;
      if (targets.length > 0) {
        var target = creep.pos.findClosestByRange(targets);
        if (creep.transfer(target, RESOURCE_ENERGY) === ERR_NOT_IN_RANGE) {
          creep.moveTo(target);
        } else {
          creep.memory.unload = false;
        }
      }


    }


  }
};