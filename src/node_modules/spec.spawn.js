var filters = require('filters')

/**
 * Spawn new creeps according to build order.
 *
 * @param {Room} room
 * @param {Object[]} buildOrder
 * @param {string} buildOrder.role
 * @param {int} buildOrder.count
 */
module.exports = (room, buildOrder) => {
  var spawns = room.find(FIND_MY_SPAWNS, {filter: filters.spawnIsBusy})

  // When all spawns are busy, skip spawn spec completely.
  if (spawns.length === 0) {
    return
  }

  var creeps = _.filter(Game.creeps, (creep) => filters.inRoom(creep, room))
  var existingRoles = _.groupBy(creeps, (creep) => creep.memory.role)

  _.reduce(_.reverse(buildOrder), (buildStep, availableSpawns) => {
    // When no more available spawn slots exist, skip further steps.
    if (availableSpawns.length === 0) {
      return []
    }

    // When the number of creeps with the specified role already exists, continue with next build step.
    if (typeof existingRoles[buildStep.role] !== 'undefined' && existingRoles[buildStep.role].length >= buildStep.count) {
      return availableSpawns
    }

    // Define base creep body.
    var basicBody = buildStep.basicBody || [WORK, CARRY, MOVE]
    var body = [].concat(basicBody)

    // If the basic body cannot be created, skip build step.
    if (availableSpawns[0].canCreateCreep(body) !== OK) {
      return availableSpawns
    }

    // Try extend body as long as it it possible.
    while (availableSpawns[0].canCreateCreep(body.concat(basicBody)) === OK) {
      body = body.concat(basicBody)
    }

    // Spawn creep.
    availableSpawns[0].createCreep(body, '', {role: buildStep.role})

    // Continue with the other spawns.
    return availableSpawns.slice(1)
  }, spawns)
  
  return false
}
