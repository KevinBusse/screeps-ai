// const job = {
//   type: 'build',
//   creep: 'creepname',
//   position: {
//     room: 'roomname',
//     x: 0,
//     y: 0
//   },
//   constructionSite: 'objectId'
// }

module.exports = {
  getCreepBody: (room, job) => {
    const energyAvailable = room.energyAvailable
    const cost = BODYPART_COST[WORK] + BODYPART_COST[CARRY] + BODYPART_COST[MOVE]
    const body = []
    for (let i = Math.min(Math.floor(50 / 3), Math.max(1, energyAvailable / cost)); i >= 1; i--) {
      body.push(WORK)
      body.push(CARRY)
      body.push(MOVE)
    }

    return body
    // let energyAvailable = room.energyAvailable
    // energyAvailable -= BODYPART_COST[WORK] + BODYPART_COST[CARRY] + BODYPART_COST[MOVE]
    // let body = [WORK, CARRY, MOVE]
    //
    // for (let i = Math.min(4, energyAvailable / BODYPART_COST[WORK]); i >= 1; i--) {
    //   body.unshift(WORK)
    // }
    // return body
  },
  execute: (creep, job) => {
    // console.log(`${creep.name} is ${creep.memory.job.type}ing using ${job.flag}`)

    if (creep.memory.building && creep.carry[RESOURCE_ENERGY] === 0) {
      creep.memory.building = false
      creep.memory.constructionSite = null
      creep.memory.repairTarget = null
    }

    if (!creep.memory.building && creep.carry[RESOURCE_ENERGY] === creep.carryCapacity) {
      creep.memory.building = true
    }

    if (creep.memory.building) {
      var constructionSite
      // if (creep.memory.constructionSite) {
      //   constructionSite = Game.getObjectById(creep.memory.constructionSite)
      //   // is contruction done?
      //   if (constructionSite && !constructionSite.progress) {
      //     constructionSite = null
      //   }
      // }

      constructionSite = creep.pos.findClosestByRange(FIND_CONSTRUCTION_SITES)
      if (constructionSite) {
        if (creep.build(constructionSite) === ERR_NOT_IN_RANGE) {
          creep.moveTo(constructionSite)
        }
        return
      }

      let repairTarget
      if (creep.memory.repairTarget) {
        repairTarget = Game.getObjectById(repairTarget)

        if (repairTarget && repairTarget.hits === repairTarget.hitsMax) {
          repairTarget = null
          creep.memory.repairTarget = null
        }
      }

      if (!repairTarget) {
        const repairTargets = creep.room.find(FIND_STRUCTURES, {filter: structure => structure.hits < structure.hitsMax})
        if (repairTargets.length > 0) {
          repairTarget = repairTargets.reduce((current, next) => current.hits < next.hits ? current : next)
          creep.memory.repairTarget = repairTarget.id
        }
      }

      if (repairTarget) {
        if (creep.repair(repairTarget) === ERR_NOT_IN_RANGE) {
          creep.moveTo(repairTarget)
        }

        return
      }

      if (creep.upgradeController(creep.room.controller) === ERR_NOT_IN_RANGE) {
        creep.moveTo(creep.room.controller)
      }
      return
    }

    var position = Game.flags[job.flag].pos
    if (creep.pos.x !== position.x || creep.pos.y !== position.y || creep.pos.room !== position.room) {
      creep.moveTo(position)
      return
    }

    var droppedEnergy = creep.pos.findInRange(FIND_DROPPED_ENERGY, 1)
    droppedEnergy
    if (droppedEnergy.length > 0) {
      creep.pickup(droppedEnergy[0])
    }
  }
}
