const filterHostile = require('filter.hostile')

const ActionNode = require('tree.node.action')

class SpawnDiggerPerSource extends ActionNode {
  open (context) {
    this.getNodeMemory(context).spawn = null
  }

  tick (context) {
    let spawn
    if (this.getNodeMemory(context).spawn) {
      spawn = Game.getObjectById(this.getNodeMemory(context).spawn)
      if (spawn.spawning) {
        return RUNNING
      }

      return SUCCESS
    }

    var room = context.actor

    var diggers = room.find(FIND_MY_CREEPS, {
      filter: creep => creep.memory.behavior === 'digger'}
    )

    var status = FAILURE
    var sources = room.find(FIND_SOURCES)
    _.each(sources, source => {
      if (status !== FAILURE) {
        return
      }

      // console.log(source.pos)
      var inDanger = source.pos.findInRange(FIND_HOSTILE_CREEPS, 5, {filter: filterHostile}).length > 0

      if (inDanger) {
        this.log(context, `Source ${source.id} is in danger, don't send digger`)
        return
      }

      var hasDigger = false
      _.each(diggers, digger => {
        if (digger.memory.digSource === source.id) {
          hasDigger = true
        }
      })

      if (hasDigger) {
        this.log(context, `Source ${source.id} already has a digger assigned`)
        return
      }

      var spawns = room.find(FIND_MY_SPAWNS, {filter: spawn => !spawn.spawning})
      if (spawns.length === 0) {
        this.log(context, 'No available spawn found')
        return
      }

      this.log(context, spawns[0], source.id)
      this.log(context, spawns[0].createCreep(
        [WORK, CARRY, MOVE],
        null,
        {behavior: 'digger', digSource: source.id}
      ))
    })

    return status
  }
}

module.exports = SpawnDiggerPerSource
