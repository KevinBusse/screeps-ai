const ActionNode = require('tree.node.action')

const sourceHasAccess = source => {
  return _.filter(
      source.room.lookForAtArea(
        LOOK_TERRAIN, source.pos.y - 1, source.pos.x - 1, source.pos.y + 1, source.pos.x + 1, true
      ),
      pos => pos.terrain !== 'wall'
    ).length - source.room.lookForAtArea(
      LOOK_CREEPS, source.pos.y - 1, source.pos.x - 1, source.pos.y + 1, source.pos.x + 1, true
    ).length
}

const getSourceWithAccess = creep => null

class Harvest extends ActionNode {
  tick (context) {
    var creep = context.actor
    if (_.sum(creep.carry) === 0) {
      creep.memory.harvesting = true
    }

    if (_.sum(creep.carry) === creep.carryCapacity) {
      creep.memory.harvesting = false
      creep.memory.lastSource = null
    }

    if (!creep.memory.harvesting) {
      return FAILURE
    }

    var sources = creep.pos.findInRange(FIND_SOURCES_ACTIVE, 1)
    if (sources.length > 0) {
      this.log(context, 'Already at a source...')
      if (creep.harvest(sources[0]) === OK) {
        this.log(context, '... harvesting')
        return RUNNING
      }
      this.log(context, 'Something is fishy, waiting at source')
      return FAILURE
    }

    if (creep.memory.lastSource) {
      this.log(context, 'Already heading for a source')
      var source = Game.getObjectById(creep.memory.lastSource)
      if (source && (source.energy > 0 || source.ticksToRegeneration < 20)) {
        this.log(context, `[Creep ${creep.name}] Source still looks good`)
        if (sourceHasAccess(source)) {
          creep.moveTo(source)
          return RUNNING
        }
        creep.memory.lastSource = null
      }
    }

    this.log(context, `[Creep ${creep.name}] Looking for best source`)
    sources = creep.room.find(FIND_SOURCES_ACTIVE)
    var sourcePriority = []
    _.each(sources, source => {
      var distance = creep.pos.findPathTo(source).length
      var numberOfAccess = _.filter(
        creep.room.lookForAtArea(
          LOOK_TERRAIN, source.pos.y - 1, source.pos.x - 1, source.pos.y + 1, source.pos.x + 1, true
        ),
        pos => pos.terrain !== 'wall'
      ).length

      var numberOfCreepsAround = creep.room.lookForAtArea(
        LOOK_CREEPS, source.pos.y - 1, source.pos.x - 1, source.pos.y + 1, source.pos.x + 1, true
      ).length

      var distanceToEnemy = 0
      var closestEnemy = source.pos.findClosestByRange(FIND_HOSTILE_CREEPS)
      if (!closestEnemy) {
        closestEnemy = source.pos.findClosestByRange(FIND_HOSTILE_STRUCTURES)
      }
      if (closestEnemy) {
        distanceToEnemy = source.pos.findPathTo(closestEnemy).length
      }

      var weight = 0
      weight += (numberOfAccess - numberOfCreepsAround) * 50
      weight += distance * -1
      weight += distanceToEnemy * 0.5
      sourcePriority.push({source: source, weight: weight})
    })
    if (sourcePriority.length === 0) {
      return FAILURE
    }

    sourcePriority.sort((a, b) => b.weight - a.weight)
    creep.memory.lastSource = sourcePriority[0].source.id
    creep.moveTo(sourcePriority[0].source)
    return RUNNING
  }
}

module.exports = Harvest
