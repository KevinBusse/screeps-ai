const filterHostile = require('filter.hostile')

const ActionNode = require('tree.node.action')

class Harvest extends ActionNode {
  tick (context) {
    var creep = context.actor
    var source

    if (_.sum(creep.carry) === 0) {
      creep.memory.harvesting = true
    }

    if (_.sum(creep.carry) === creep.carryCapacity) {
      creep.memory.harvesting = false
      creep.memory.lastSource = null
    }

    if (!creep.memory.harvesting) {
      return SUCCESS
    }

    var sources = creep.pos.findInRange(FIND_SOURCES_ACTIVE, 1)
    if (sources.length > 0) {
      this.log(context, 'Already at a source...')
      if (creep.harvest(sources[0]) === OK) {
        this.log(context, '... harvesting')
        return RUNNING
      }
      this.log(context, 'Something is fishy, waiting at source')
      return RUNNING
    }

    const sourceHasAccess = source => {
      return _.filter(
          source.room.lookForAtArea(
            LOOK_TERRAIN, source.pos.y - 1, source.pos.x - 1, source.pos.y + 1, source.pos.x + 1, true
          ),
          pos => pos.terrain !== 'wall'
        ).length - source.room.lookForAtArea(
          LOOK_CREEPS, source.pos.y - 1, source.pos.x - 1, source.pos.y + 1, source.pos.x + 1, true
        ).length
    }

    const findSourceWithAccess = () => {
      const sources = creep.room.find(FIND_SOURCES_ACTIVE)
      var sourcePriority = []
      _.each(sources, source => {
        var distance = creep.pos.findPathTo(source).length
        var numberOfAccess = _.filter(
          creep.room.lookForAtArea(
            LOOK_TERRAIN, source.pos.y - 1, source.pos.x - 1, source.pos.y + 1, source.pos.x + 1, true
          ),
          pos => pos.terrain !== 'wall'
        ).length

        if (source.pos.findInRange(FIND_HOSTILE_CREEPS, 5, {filter: filterHostile})) {
          return
        }

        var numberOfCreepsAround = creep.room.lookForAtArea(
          LOOK_CREEPS, source.pos.y - 1, source.pos.x - 1, source.pos.y + 1, source.pos.x + 1, true
        ).length

        var weight = (numberOfAccess - numberOfCreepsAround) / distance
        sourcePriority.push({source: source, weight: weight})
      })

      if (sourcePriority.length > 0) {
        this.log(context, 'Picked source by priority')
        return sourcePriority[0]
      }

      this.log(context, 'Picked source randomly')
      return _.sample(sources)
    }

    if (creep.memory.lastSource) {
      this.log(context, 'Already heading for a source')
      source = Game.getObjectById(creep.memory.lastSource)
      if (source && (source.energy > 0 || source.ticksToRegeneration < 20)) {
        this.log(context, 'Source still looks good')
        if (sourceHasAccess(source)) {
          creep.moveTo(source)
          return RUNNING
        }
        creep.memory.lastSource = null
      }
    }

    source = findSourceWithAccess()
    creep.memory.lastSource = source.id
    creep.moveTo(source)
    return RUNNING
  }
}

module.exports = Harvest
