const ActionNode = require('tree.node.action')

class Pickup extends ActionNode {
  tick (context) {
    var creep = context.actor

    if (_.sum(creep.carry) === 0) {
      creep.memory.canPickup = true
    }

    var carry = _.sum(creep.carry)
    if (carry === creep.carryCapacity) {
      creep.memory.canPickup = false
    }

    this.log(context, `lastDropSite: ${creep.memory.lastDropSite} carry: ${carry}/${creep.carryCapacity} canPickup: ${creep.memory.canPickup}`)

    if (!creep.memory.canPickup) {
      return SUCCESS
    }

    if (creep.memory.lastDropSite) {
      const lastDropSite = Game.getObjectById(creep.memory.lastDropSite)
      if (lastDropSite) {
        this.log(context, `DropSite is still there with ${lastDropSite.energy} energy`)
        if (creep.pickup(lastDropSite) === ERR_NOT_IN_RANGE) {
          creep.moveTo(lastDropSite)
        }
        return RUNNING
      }

      creep.memory.lastDropSite = null
    }

    // TODO: filter safe drop sites
    const drops = creep.room.find(FIND_DROPPED_ENERGY)

    if (drops.length === 0) {
      return FAILURE
    }

    const getWeightedSample = (array, weight) => {
      var sum = array.reduce((memo, item) => memo + weight(item), 0)
      var position = sum * Math.random()
      for (var i = 0; i < array.length; i++) {
        if (position <= 0) {
          return array[i]
        }

        position -= weight(array[i])
      }
    }

    var dropSite = getWeightedSample(drops, dropSite => dropSite.energy)
    this.log(context, `Picked dropSite ${dropSite.id} randomly with ${dropSite.energy} left`)
    creep.memory.lastDropSite = dropSite.id
    creep.moveTo(dropSite)

    return RUNNING
  }
}

module.exports = Pickup
