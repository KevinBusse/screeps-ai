const ActionNode = require('tree.node.action')

const fib = (n) => n < 2 ? 1 : fib(n - 1) + fib(n - 2)

class SpawnCreep extends ActionNode {
  open (context) {
    this.getNodeMemory(context).spawn = null
  }

  tick (context) {
    let spawn
    if (this.getNodeMemory(context).spawn) {
      spawn = Game.getObjectById(this.getNodeMemory(context).spawn)
      if (spawn.spawning) {
        return RUNNING
      }

      return SUCCESS
    }

    var room = context.actor

    var existingCreeps = room.find(FIND_MY_CREEPS, {
      filter: creep => creep.memory.behavior === this.params.behavior
    }).length

    if (this.params.max) {
      this.log(context, `${existingCreeps} / ${this.params.max} with behavior ${this.params.behavior}`)
      if (existingCreeps >= this.params.max) {
        this.log(context, `Enough creeps with behavior ${this.params.behavior}`)
        return FAILURE
      }
    }

    var spawns = room.find(FIND_MY_SPAWNS, {filter: spawn => !spawn.spawning})
    if (spawns.length === 0) {
      this.log(context, 'No available spawn found')
      return FAILURE
    }

    var baseBody = this.params.baseBody
    var scaleBody = this.params.scaleBody
    var baseCost = _.reduce(_.map(baseBody, bodyPart => BODYPART_COST[bodyPart]), (a, b) => a + b, 0)
    var scaleCost = _.reduce(_.map(scaleBody, bodyPart => BODYPART_COST[bodyPart]), (a, b) => a + b, 0)
    var size = Math.min(Math.floor((room.energyCapacityAvailable - baseCost) / scaleCost), fib(existingCreeps))
    var body = baseBody
    _.each(scaleBody, bodyPart => {
      for (var i = 0; i < size; i++) {
        body.push(bodyPart)
      }
    })

    if (spawns[0].canCreateCreep(body) !== OK) {
      this.log(context, 'Spawn cannot create creep')
      return FAILURE
    }

    var status = spawns[0].createCreep(body, null, {behavior: this.params.behavior})
    if (status === OK) {
      return RUNNING
    }

    this.log(context, `Spawning error ${status}`)
    return FAILURE
  }
}

module.exports = SpawnCreep
