const ActionNode = require('tree.node.action')

class EnergyAvailable extends ActionNode {
  tick (context) {
    super.tick(context)

    var room = context.actor
    if (room.energyAvailable >= this.params.min) {
      return SUCCESS
    }

    return FAILURE
  }
}
global.EnergyAvailable = EnergyAvailable

class UpkeepAllowsSpawning extends ActionNode {
  tick (context) {
    super.tick(context)

    var room = context.actor
    var upkeepPerCreep = this.params.upkeep || 50
    var creepCount = room.find(FIND_MY_CREEPS).length
    this.log(context, `[Room ${room.name}] ${creepCount} / ${room.energyCapacityAvailable / upkeepPerCreep}`)
    if (creepCount < room.energyCapacityAvailable / upkeepPerCreep) {
      return SUCCESS
    }

    return FAILURE
  }
}
global.UpkeepAllowsSpawning = UpkeepAllowsSpawning

const fib = (n) => n < 2 ? 1 : global.fib(n - 1) + global.fib(n - 2)

class SpawnCreep extends ActionNode {
  open (context) {
    super.open(context)

    this.getNodeMemory(context).openTime = Game.time
    this.getNodeMemory(context).building = false
  }

  tick (context) {
    super.tick(context)
    if (this.getNodeMemory(context).building && this.getNodeMemory(context).openTime < Game.time) {
      return SUCCESS
    }

    var room = context.actor

    var existingCreeps = room.find(FIND_MY_CREEPS, {filter: creep => creep.memory.behavior === this.params.behavior}).length
    if (this.params.max) {
      this.log(context, `[Room ${room.name}] ${existingCreeps} / ${this.params.max} with behavior ${this.params.behavior}`)
      if (existingCreeps >= this.params.max) {
        return SUCCESS
      }
    }

    var spawns = room.find(FIND_MY_SPAWNS, {filter: spawn => !spawn.spawning})
    if (spawns.length === 0) {
      this.log(context, `[Room ${room.name}] No available spawn found`)
      return FAILURE
    }

    var baseBody = this.params.body
    var baseCost = _.reduce(_.map(baseBody, bodyPart => BODYPART_COST[bodyPart]), (a, b) => a + b, 0)
    var size = Math.min(Math.floor(room.energyCapacityAvailable / baseCost), fib(existingCreeps))
    var body = []
    _.each(baseBody, bodyPart => {
      for (var i = 0; i < size; i++) {
        body.push(bodyPart)
      }
    })

    spawns[0].createCreep(body, null, {behavior: this.params.behavior})
    return RUNNING
  }
}
global.SpawnCreep = SpawnCreep

class BuildExtensions extends ActionNode {
  tick (context) {
    super.tick(context)

    var room = context.actor
    var possibleExtensions = CONTROLLER_STRUCTURES[STRUCTURE_EXTENSION][room.controller.level]
    var existingExtensions = room.find(FIND_MY_STRUCTURES, {filter: structure => structure.structureType === STRUCTURE_EXTENSION}).length
    this.log(context, `[Room ${room.name}] ${existingExtensions} / ${possibleExtensions} extensions`)

    if (existingExtensions >= possibleExtensions) {
      this.log(context, `[Room ${room.name}] No more extensions available`)
      return FAILURE
    }

    var extensionsInContruction = room.find(FIND_MY_CONSTRUCTION_SITES, {filter: site => site.structureType === STRUCTURE_EXTENSION}).length
    if (extensionsInContruction > 0) {
      this.log(context, `[Room ${room.name}] An extensions is still under construction`)
      return RUNNING
    }

    var spawn = room.find(FIND_MY_SPAWNS)[0]
    if (!spawn) {
      this.log(context, `[Room ${room.name}] No spawn found to align extensions`)
      return FAILURE
    }

    var findPlains = (x, y) => {
      var terrain = room.lookForAtArea(LOOK_TERRAIN, y - 1, x - 1, y + 1, x + 1, true)
      return _.filter(terrain, pos => pos.terrain !== 'wall').length
    }

    var positionFound = false
    for (var i = 2; !positionFound; i++) {
      if (i % 4 === 2) {
        continue
      }
      var steps = 2 - i % 2
      var step = 0
      var x = 0
      var y = -i
      for (; x < i; x++, y++, step++) {
        if (step % steps === 0) {
          if (room.lookForAt(LOOK_STRUCTURES, spawn.pos.x + x, spawn.pos.y + y).length !== 0) {
            continue
          }
          if (findPlains(spawn.pos.x + x, spawn.pos.y + y) === 9) {
            if (room.createConstructionSite(spawn.pos.x + x, spawn.pos.y + y, STRUCTURE_EXTENSION) === OK) {
              this.log(context, `[Room ${room.name}] An extension construction has been issued`)
              return RUNNING
            }
          }
        }
      }
      for (; y < i; x--, y++, step++) {
        if (step % steps === 0) {
          if (room.lookForAt(LOOK_STRUCTURES, spawn.pos.x + x, spawn.pos.y + y).length !== 0) {
            continue
          }
          if (findPlains(spawn.pos.x + x, spawn.pos.y + y) === 9) {
            if (room.createConstructionSite(spawn.pos.x + x, spawn.pos.y + y, STRUCTURE_EXTENSION) === OK) {
              this.log(context, `[Room ${room.name}] An extension construction has been issued`)
              return RUNNING
            }
          }
        }
      }
      for (; x > -i; x--, y--, step++) {
        if (step % steps === 0) {
          if (room.lookForAt(LOOK_STRUCTURES, spawn.pos.x + x, spawn.pos.y + y).length !== 0) {
            continue
          }
          if (findPlains(spawn.pos.x + x, spawn.pos.y + y) === 9) {
            if (room.createConstructionSite(spawn.pos.x + x, spawn.pos.y + y, STRUCTURE_EXTENSION) === OK) {
              this.log(context, `[Room ${room.name}] An extension construction has been issued`)
              return RUNNING
            }
          }
        }
      }
      for (; y > -i; x++, y--, step++) {
        if (step % steps === 0) {
          if (room.lookForAt(LOOK_STRUCTURES, spawn.pos.x + x, spawn.pos.y + y).length !== 0) {
            continue
          }
          if (findPlains(spawn.pos.x + x, spawn.pos.y + y) === 9) {
            if (room.createConstructionSite(spawn.pos.x + x, spawn.pos.y + y, STRUCTURE_EXTENSION) === OK) {
              this.log(context, `[Room ${room.name}] An extension construction has been issued`)
              return RUNNING
            }
          }
        }
      }

      // Just a precaution to prevent infinite looping
      if (i === 25) {
        break
      }
    }

    return FAILURE
  }
}
global.BuildExtensions = BuildExtensions
