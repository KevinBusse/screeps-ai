const ActionNode = require('tree.node.action')

class Dismantle extends ActionNode {
  tick (context) {
    super.tick(context)

    var creep = context.actor

    if (!this.params.id) {
      this.log(context, `[Creep ${creep.name}] No id provided for object to dismantle`)
      return SUCCESS
    }

    var roomObject = Game.getObjectById(this.params.id)

    if (!roomObject) {
      this.log(context, `[Creep ${creep.name}] Object to dismantle could not be found`)
      return SUCCESS
    }

    this.log(context, `[Creep ${creep.name}] Dismantling ${this.params.id}`)
    console.log(creep.dismantle(roomObject))
    if (creep.dismantle(roomObject) === ERR_NOT_IN_RANGE) {
      this.log(context, `[Creep ${creep.name}] ... oops, not in range yet, moving closer`)
      creep.moveTo(roomObject)
    }
    return RUNNING
  }
}
global.Dismantle = Dismantle

class Harvest extends ActionNode {
  tick (context) {
    super.tick(context)

    var creep = context.actor
    if (_.sum(creep.carry) === 0) {
      if (creep.memory.harvesting === false) {
        this.log(context, `[Creep ${creep.name}] Forgetting about last source`)
        creep.memory.lastSource = null
      }
      creep.memory.harvesting = true
    }

    if (_.sum(creep.carry) === creep.carryCapacity) {
      creep.memory.harvesting = false
    }

    if (!creep.memory.harvesting) {
      return SUCCESS
    }

    var sources = creep.pos.findInRange(FIND_SOURCES_ACTIVE, 1)
    if (sources.length > 0) {
      this.log(context, `[Creep ${creep.name}] Already at a source...`)
      if (creep.harvest(sources[0]) === OK) {
        this.log(context, `[Creep ${creep.name}] ... harvesting`)
        return RUNNING
      }
      this.log(context, `[Creep ${creep.name}] Something is fishy, waiting at source`)
      return FAILURE
    }

    var sourceIsAccessible = (source) =>
    _.filter(source.room.lookForAtArea(LOOK_TERRAIN, source.pos.y - 1, source.pos.x - 1, source.pos.y + 1, source.pos.x + 1, true), pos => pos.terrain !== 'wall').length -
    source.room.lookForAtArea(LOOK_CREEPS, source.pos.y - 1, source.pos.x - 1, source.pos.y + 1, source.pos.x + 1, true).length

    if (creep.memory.lastSource) {
      this.log(context, `[Creep ${creep.name}] Aready decided for a source`)
      var source = Game.getObjectById(creep.memory.lastSource)
      if (source && (source.energy > 0 || source.ticksToRegeneration < 20)) {
        this.log(context, `[Creep ${creep.name}] Source still looks good`)
        if (sourceIsAccessible(source)) {
          creep.moveTo(source)
          return
        }
        creep.memory.lastSource = null
      }
    }

    this.log(context, `[Creep ${creep.name}] Looking for best source`)
    sources = creep.room.find(FIND_SOURCES_ACTIVE)
    var sourcePriority = []
    _.each(sources, source => {
      var distance = creep.pos.findPathTo(source).length
      var numberOfAccess = _.filter(creep.room.lookForAtArea(LOOK_TERRAIN, source.pos.y - 1, source.pos.x - 1, source.pos.y + 1, source.pos.x + 1, true), pos => pos.terrain !== 'wall').length
      var numberOfCreepsAround = creep.room.lookForAtArea(LOOK_CREEPS, source.pos.y - 1, source.pos.x - 1, source.pos.y + 1, source.pos.x + 1, true).length
      var distanceToEnemy = 0
      var closestEnemy = source.pos.findClosestByRange(FIND_HOSTILE_CREEPS)
      if (!closestEnemy) {
        closestEnemy = source.pos.findClosestByRange(FIND_HOSTILE_STRUCTURES)
      }
      if (closestEnemy) {
        distanceToEnemy = source.pos.findPathTo(closestEnemy).length
      }

      var weight = 0
      weight += (numberOfAccess - numberOfCreepsAround)
      weight += distance * -1
      weight += distanceToEnemy / 2
      sourcePriority.push({source: source, weight: weight})
    })
    sourcePriority.sort((a, b) => b.weight - a.weight)
    if (sourcePriority.length > 0) {
      creep.memory.lastSource = sourcePriority[0].source.id
      creep.moveTo(sourcePriority[0].source)
    }
  }
}
global.Harvest = Harvest

class Construct extends ActionNode {
  tick (context) {
    super.tick(context)

    var creep = context.actor
    var sites = creep.room.find(FIND_MY_CONSTRUCTION_SITES)
    if (sites.length === 0) {
      this.log(context, `[Creep ${creep.name}] Nothing to construct`)
      return SUCCESS
    }

    if (creep.energy === 0) {
      return FAILURE
    }

    var site = creep.pos.findClosestByPath(sites)
    if (creep.build(site) === ERR_NOT_IN_RANGE) {
      creep.moveTo(site)
    }

    return RUNNING
  }

}
global.Construct = Construct

class TransferEnergyToSpawn extends ActionNode {
  tick (context) {
    super.tick(context)

    var creep = context.actor
    var target = creep.pos.findClosestByPath(FIND_MY_SPAWNS, {filter: spawn => spawn.energy < spawn.energyCapacity})
    if (!target) {
      return SUCCESS
    }

    if (creep.transfer(target, RESOURCE_ENERGY) === ERR_NOT_IN_RANGE) {
      creep.moveTo(target)
    }
  }
}
global.TransferEnergyToSpawn = TransferEnergyToSpawn

class TransferEnergy extends ActionNode {
  tick (context) {
    super.tick(context)

    var creep = context.actor
    var target = creep.pos.findClosestByPath(FIND_MY_STRUCTURES, {filter: structure => structure.type === this.params.type && structure.energy < structure.energyCapacity})
    if (!target) {
      return SUCCESS
    }

    if (creep.transfer(target, RESOURCE_ENERGY) === ERR_NOT_IN_RANGE) {
      creep.moveTo(target)
    }
  }
}
global.TransferEnergy = TransferEnergy

class UpgradeController extends ActionNode {
  tick (context) {
    super.tick(context)

    var creep = context.actor

    var status = creep.upgradeController(creep.room.controller)
    if (status === OK) {
      this.log(context, `[Creep ${creep.name}] Upgrading controller`)
      return
    }

    if (status === ERR_NOT_IN_RANGE) {
      this.log(context, `[Creep ${creep.name}] Tried to upgrade controller, but need to move closer to controller`)
      creep.moveTo(creep.room.controller)
      return
    }

    this.log(context, `[Creep ${creep.name}] ... something strange happened while trying to upgrade the controller`)
  }
}
global.UpgradeController = UpgradeController

class Suicide extends ActionNode {
  tick (context) {
    super.tick(context)

    var creep = context.actor
    creep.suicide()
  }
}
global.Suicide = Suicide
