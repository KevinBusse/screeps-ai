// const job = {
//   type: 'upgrade',
//   creep: 'creepname',
//   position: {
//     room: 'roomname',
//     x: 0,
//     y: 0
//   }
// }

module.exports = {
  getCreepBody: (room, job) => {
    const energyAvailable = room.energyAvailable
    const cost = BODYPART_COST[WORK] + BODYPART_COST[CARRY] + BODYPART_COST[MOVE]
    const body = []
    for (let i = Math.max(1, energyAvailable / cost); i >= 1; i--) {
      body.push(WORK)
      body.push(CARRY)
      body.push(MOVE)
    }

    return body

    // energyAvailable -= BODYPART_COST[WORK] + BODYPART_COST[CARRY] + BODYPART_COST[MOVE]
    // let body = [WORK, CARRY, MOVE]
    //
    // for (let i = Math.min(4, energyAvailable / BODYPART_COST[WORK]); i >= 1; i--) {
    //   body.unshift(WORK)
    // }
    // return body
  },
  execute: (creep, job) => {
    if (creep.memory.upgrading && creep.carry[RESOURCE_ENERGY] === 0) {
      creep.memory.upgrading = false
    }

    if (!creep.memory.upgrading && creep.carry[RESOURCE_ENERGY] === creep.carryCapacity) {
      creep.memory.upgrading = true
    }

    if (creep.memory.upgrading) {
      if (creep.upgradeController(creep.room.controller) === ERR_NOT_IN_RANGE) {
        creep.moveTo(creep.room.controller)
      }
      return
    }

    if (creep.room.storage) {
      if (creep.room.storage.store[RESOURCE_ENERGY] > 0) {
        // console.log(`${creep.name} withdraw`)
        if (creep.withdraw(creep.room.storage, RESOURCE_ENERGY) === ERR_NOT_IN_RANGE) {
          // console.log(`${creep.name} move`)
          creep.moveTo(creep.room.storage)
        }
        return
      }
    }

    var position = Game.flags[job.flag].pos

    if (creep.pos.x !== position.x || creep.pos.y !== position.y || creep.pos.room !== position.room) {
      creep.moveTo(position)
      return
    }

    var droppedEnergy = creep.pos.findInRange(FIND_DROPPED_ENERGY, 1)
    if (droppedEnergy.length > 0) {
      creep.pickup(droppedEnergy[0])
    }
  }
}
