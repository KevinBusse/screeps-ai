const ActionNode = require('tree.node.action')

class BuildStructure extends ActionNode {
  tick (context) {
    var structureType = this.params.structureType
    var room = context.actor
    var possibleStructures = CONTROLLER_STRUCTURES[structureType][room.controller.level]
    var existingStructures = room.find(FIND_MY_STRUCTURES, {
      filter: structure => structure.structureType === structureType}
    ).length

    this.log(context, `[Room ${room.name}] ${existingStructures} / ${possibleStructures} ${structureType}s`)
    if (existingStructures >= possibleStructures) {
      this.log(context, `[Room ${room.name}] No more ${structureType}s available`)
      return FAILURE
    }

    var extensionsInContruction = room.find(FIND_MY_CONSTRUCTION_SITES, {
      filter: site => site.structureType === structureType
    }).length
    if (extensionsInContruction > 0) {
      this.log(context, `[Room ${room.name}] ${structureType} is still under construction`)
      return RUNNING
    }

    var spawn = room.find(FIND_MY_SPAWNS)[0]
    if (!spawn) {
      this.log(context, `[Room ${room.name}] No spawn found to align ${structureType}`)
      return FAILURE
    }

    var findPlains = (x, y) => {
      var terrain = room.lookForAtArea(LOOK_TERRAIN, y - 1, x - 1, y + 1, x + 1, true)
      return _.filter(terrain, pos => pos.terrain !== 'wall').length
    }

    for (var i = 2; i < 25; i++) {
      if (i % 4 === 2) {
        continue
      }
      var steps = 2 - i % 2
      var step = 0
      var x = 0
      var y = -i
      for (; x < i; x++, y++, step++) {
        if (step % steps === 0) {
          if (room.lookForAt(LOOK_STRUCTURES, spawn.pos.x + x, spawn.pos.y + y).length !== 0) {
            continue
          }
          if (findPlains(spawn.pos.x + x, spawn.pos.y + y) === 9) {
            if (room.createConstructionSite(spawn.pos.x + x, spawn.pos.y + y, structureType) === OK) {
              this.log(context, `[Room ${room.name}] A ${structureType} construction has been issued`)
              return RUNNING
            }
          }
        }
      }
      for (; y < i; x--, y++, step++) {
        if (step % steps === 0) {
          if (room.lookForAt(LOOK_STRUCTURES, spawn.pos.x + x, spawn.pos.y + y).length !== 0) {
            continue
          }
          if (findPlains(spawn.pos.x + x, spawn.pos.y + y) === 9) {
            if (room.createConstructionSite(spawn.pos.x + x, spawn.pos.y + y, structureType) === OK) {
              this.log(context, `[Room ${room.name}] A ${structureType} construction has been issued`)
              return RUNNING
            }
          }
        }
      }
      for (; x > -i; x--, y--, step++) {
        if (step % steps === 0) {
          if (room.lookForAt(LOOK_STRUCTURES, spawn.pos.x + x, spawn.pos.y + y).length !== 0) {
            continue
          }
          if (findPlains(spawn.pos.x + x, spawn.pos.y + y) === 9) {
            if (room.createConstructionSite(spawn.pos.x + x, spawn.pos.y + y, structureType) === OK) {
              this.log(context, `[Room ${room.name}] A ${structureType} construction has been issued`)
              return RUNNING
            }
          }
        }
      }
      for (; y > -i; x++, y--, step++) {
        if (step % steps === 0) {
          if (room.lookForAt(LOOK_STRUCTURES, spawn.pos.x + x, spawn.pos.y + y).length !== 0) {
            continue
          }
          if (findPlains(spawn.pos.x + x, spawn.pos.y + y) === 9) {
            if (room.createConstructionSite(spawn.pos.x + x, spawn.pos.y + y, structureType) === OK) {
              this.log(context, `[Room ${room.name}] An ${structureType} construction has been issued`)
              return RUNNING
            }
          }
        }
      }
    }

    return FAILURE
  }
}

module.exports = BuildStructure
